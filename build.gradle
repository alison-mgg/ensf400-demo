buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "com.github.spacialcircumstances:gradle-cucumber-reporting:0.1.23"
    }
}

plugins {
    id 'war'
    id 'org.gretty' version '3.1.5'
    id "org.flywaydb.flyway" version "6.0.8"
    id "org.sonarqube" version "3.0"
    id 'jacoco'
    id "com.dorongold.task-tree" version "1.4"
    id 'info.solidsoft.pitest' version '1.5.1'
    id "org.owasp.dependencycheck" version "6.1.6"
    id 'org.hidetake.ssh' version '2.10.1'
    id "org.checkerframework" version "0.5.0"
    id "java-library"
}

javadoc {
    options.overview = "src/main/javadoc/overview.html"
}

repositories {
    mavenCentral()
    jcenter()
}

// apply our fancy cucumber reporting program, see https://plugins.gradle.org/plugin/com.github.spacialcircumstances.gradle-cucumber-reporting
apply plugin: "com.github.spacialcircumstances.gradle-cucumber-reporting"

apply plugin: 'org.checkerframework'

// including our script plugin for running our integration tests
apply from: "$rootDir/gradle/integration_tests.gradle"

// including our script plugin for running BDD-type tests
apply from: "$rootDir/gradle/cucumber_bdd_tests.gradle"

// our script plugin for provisioning servers
apply from: "$rootDir/gradle/remote_actions.gradle"

tasks.withType(JavaCompile) {
    options.compilerArgs << "--release" << "17"
}

checkerFramework {

}

// configure jetty to run on port 8080 when we run "./gradlew appRun"
gretty {
    httpPort = 8080
    servletContainer = 'tomcat9'
    contextPath = "demo"
    def jacocoAgent = zipTree(configurations.jacocoAgent.singleFile).filter { it.name == "jacocoagent.jar" }.singleFile
    jvmArgs = ["-javaagent:$jacocoAgent=output=tcpserver,address=localhost,port=6300", '-Dcom.sun.management.jmxremote', '-Dcom.sun.management.jmxremote.port=9999', '-Dcom.sun.management.jmxremote.ssl=false', '-Dcom.sun.management.jmxremote.authenticate=false']
}

repositories {
    jcenter()
    mavenCentral()
}

configurations {
    localDeps
}

dependencies {
    providedCompile 'javax.servlet:javax.servlet-api:4.0.1'
    testImplementation 'junit:junit:4.13'
    testImplementation 'org.mockito:mockito-core:3.3.3'
    implementation group: 'me.gosimple', name: 'nbvcxz', version: '1.4.3'
    testImplementation group: 'nl.jqno.equalsverifier', name: 'equalsverifier', version: '3.19.3'
    testImplementation 'io.cucumber:cucumber-java:5.7.0'
    testImplementation 'io.cucumber:cucumber-junit:5.7.0'
    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.10'
    implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.13.2'
    implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.13.2'
    implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.13.2'
    localDeps group: 'com.h2database', name: 'h2', version: '1.4.200'
    implementation configurations.localDeps
    implementation "org.flywaydb:flyway-core:6.4.1"
    implementation group: 'net.bull.javamelody', name: 'javamelody-core', version: '1.85.0'
}


pitest {
    targetClasses = ['com.coveros.training.authentication.RegisterServlet', 'com.coveros.training.authentication.RegisterServletTests']
    threads = 4
    outputFormats = ['XML', 'HTML']
    timestampedReports = false
}

tasks.withType(JavaCompile) {
    options.compilerArgs << "--release" << "17"
}

tasks.withType(Test) {
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
    failFast = true

    testLogging {
        exceptionFormat "full"
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showExceptions true
        showStandardStreams true
    }

    finalizedBy jacocoTestReport
}

// configuration for the cucumber reports.
cucumberReports {
    outputDir = file('build/reports/bdd')
    buildId = '1'
    // merge together all the cucumber reports with a suffix of "json"
    reports = files(fileTree(dir: "build/bdd", include: '*.json'))
    testTasksFinalizedByReport = false
    projectNameOverride = "$projectname"
}

flyway {
    
    url = 'jdbc:h2:./build/db/training;AUTO_SERVER=TRUE;MODE=POSTGRESQL'
    driver = 'org.h2.Driver'
    user = ""
    password = ""
    schemas = ['ADMINISTRATIVE', 'LIBRARY', 'AUTH']
}

/**
 * Put the h2 dependency in a convenient place so we can run it from
 * the command line.
 */
task copyH2JarToLib(type: Copy) {
    from configurations.localDeps
    into "$buildDir/lib"
}

// starts the h2 console
task startH2Console(type: Exec) {
    dependsOn 'copyH2JarToLib'
    commandLine 'javaw', '-cp', 'build/lib/h2-1.4.199.jar', 'org.h2.tools.Console'
}

generateCucumberReports.dependsOn(cucumber)

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

jacocoTestReport {
    executionData(fileTree(dir: "$buildDir/jacoco", include: '*.exec'))
    reports {
        xml.enabled true
        csv.enabled false
        xml.destination file("${buildDir}/jacoco/jacoco.xml")
        html.destination file("${buildDir}/reports/jacoco")
    }
}

check.dependsOn jacocoTestReport

sonarqube {
    properties {
        property "sonar.projectKey", "$projectname"
        property "sonar.projectName", "$projectname"
        property "sonar.projectDescription", "A demonstration of a web application with good test coverage and best practices"
        property "sonar.sources", "src/main/java"
        property "sonar.tests", "src/test/java,src/integration_test/java,src/bdd_test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test/,build/test-results/integrate"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/jacoco/jacoco.xml"
        property "sonar.host.url", "http://host.docker.internal:9001"
        property "sonar.projectKey", "ENSF400-DEMO"
        property "sonar.projectName", "ENSF400-DEMO"
    }
}

tasks.withType(Test) {
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
    failFast = true
}

task runApiTests(type: Exec) {
    doFirst {
        checkIfAlive()
    }
    workingDir 'src/api_tests'
    commandLine 'pipenv', 'run', 'pytest', '--junitxml', '../../build/test-results/api_tests/TEST-api_test_results.xml'
}

static boolean SearchDirectoryForChromedriver(File dir) {
    return dir.listFiles({ file -> file.name.contains("chromedriver") } as FileFilter).any()
}

static boolean ScanPathForChromeDriver() {
    // Add all the directories from the system PATH variable
    List pathDirectories = System.getenv('PATH').split("[;|:]").toList()

    pathDirectories.add("ui_tests")

    return pathDirectories.any({ dir -> SearchDirectoryForChromedriver(new File(dir)) })
}

task('writeGitCommitToFile') {
    File file = new File("src/main/webapp/commit.html")
    file.write(getCurrentGitHash() )
}
static String getCurrentGitHash() {
    String headFileLocation = ".git/HEAD"
    String commitLocation
    int locationOfSpace
    String currentHead
    FileReader fr_forGitHead
    FileReader fr_forGitHash
    String result
    boolean shouldExit = false

    try {
        fr_forGitHead = new FileReader(headFileLocation)
    } catch (Exception ignored) {
        return "NO_GIT_HEAD_FOUND"
    }

    new BufferedReader(fr_forGitHead).with { br ->
        // get the directory to the current HEAD
        result = "EMPTY_INITIAL_VALUE"
        try {
            currentHead = br.readLine()
        } catch (Exception ignored) {
            result = "COULD_NOT_READ_HEAD_FILE"
            shouldExit = true
        }
        finally {
            br.close()
        }
        locationOfSpace = currentHead.indexOf(" ")
        // extract out the portion that is the directory only
        // the whole contents go something like: "ref: refs/heads/master"
        commitLocation = currentHead.substring(locationOfSpace + 1)
        // read the file at that location (e.g. .git/refs/heads/master )
    }
    if (shouldExit) {
        return result
    }

    try {
        fr_forGitHash = new FileReader(".git/" + commitLocation)
    } catch (Exception ignored) {
        return "NO_GIT_HASH_FILE_FOUND"
    }

    new BufferedReader(fr_forGitHash).with { br ->
        result = "EMPTY_AT_BEGINNING"
        try {
            result = br.readLine()
        } catch (Exception ignored) {
            result = "COULD_NOT_READ_COMMIT_HASH"
        } finally {
            br.close()
        }
    }
    return result
}

compileJava.finalizedBy writeGitCommitToFile

// returns true if the application is running.
static void checkIfAlive() {
    int code
    try {
        URL url = new URL("http://localhost:8080/demo")
        HttpURLConnection connection = (HttpURLConnection) url.openConnection()
        connection.setRequestMethod("GET")
        connection.connect()

        code = connection.getResponseCode()
    } catch (Exception ignored) {
        String errorMsg = "\n\n\n" +
                "****************************************\n" +
                "*       SERVER IS NOT RUNNING          *\n" +
                "****************************************\n" +
                " The server has to be running to run    \n" +
                " tests you requested                    \n" +
                "                                        \n" +
                " To start the app:                      \n" +
                "    gradlew apprun                   \n" +
                "****************************************\n"
        throw new Exception(errorMsg)
    }
    if (code != 200) {
        throw new Exception("\n\nServer is not returning a 200.  Instead, it is: " +code + "\n\n")
    }
}

void waitForHeartbeat() {
    int code = 0
    while (code != 200){
        try {
            URL url = new URL("http://localhost:8080/demo")
            HttpURLConnection connection = (HttpURLConnection) url.openConnection()
            connection.setRequestMethod("GET")
            connection.connect()

            code = connection.getResponseCode()

            if (code != 200) {
                logger.error("\nServer response is: " +code + ".  Waiting 2 seconds")
                sleep 2
            } else {
                logger.info("\nServer is awake")
            }
        } catch (Exception ignored) {
            logger.error("\nServer failed to connect.  Waiting 2 seconds")
            sleep 2
        }
    }
}

task waitForHeartbeatTask() {
    doLast {
        waitForHeartbeat()
    }
}

task checkQualityGate() {
    doLast {
        isQualityGateGood()
    }
}

// throws an exception if the quality gate fails.
static void isQualityGateGood() {
    def sonarHost = "http://sonarqube:9000" // Use the correct hostname for Docker network
    def projectKey = "ENSF400-DEMO" // Ensure this matches your SonarQube project key exactly
    def token = System.getenv("SONAR_TOKEN") // Optional: use Jenkins env var

    if (token == null || token.trim().isEmpty()) {
        throw new GradleException("SONAR_TOKEN environment variable is not set")
    }

    def url = new URL("${sonarHost}/api/qualitygates/project_status?projectKey=${projectKey}")
    def connection = (HttpURLConnection) url.openConnection()
    connection.setRequestMethod("GET")
    connection.setRequestProperty("Authorization", "Basic " + "${token}:".bytes.encodeBase64().toString())
    connection.connect()

    int code = connection.getResponseCode()

    if (code != 200) {
        throw new GradleException("SonarQube response code was " + code)
    }

    def response = connection.inputStream.text
    println("SonarQube quality gate response: " + response)

    if (response.contains('"status":"ERROR"')) {
        throw new GradleException("The quality gate for ${projectKey} on SonarQube failed. Check SonarQube.")
    }
}


task runBehaveTests(type: Exec) {
    doFirst {
        checkIfAlive()
        def chromedriver_exists_in_ui_tests = ScanPathForChromeDriver()
		def chrm = project.properties['chromedriver.path']

		// make sure that the path to chromedriver isn't null or empty:
		def chromedriver_full_path_empty = chrm == null || chrm.isEmpty()
        if (chromedriver_full_path_empty) {
            chrm = "(NOT SET)"
        }

        if (!chromedriver_exists_in_ui_tests && chromedriver_full_path_empty) {
            ignoreExitValue true
            throw new Exception(


					"\n\n*****************************************************\n" +
					"*****************************************************\n" +
					"Does not look like you have Chromedriver on your \n" +
					"PATH or have set the full directory in gradle.properties.\n\n" +

					"Download it from http://chromedriver.chromium.org/\n" +
					"*****************************************************\n" +
					"*****************************************************\n" +


					"\n\nMore detail:\n  We couldn't find Chromedriver, which is needed to run the \n" +
					"  Behave tests (The UI-focused Behavior Driven Development test)\n" +

					"\nThe easiest way to fix this, once you have downloaded Chromedriver, \n" +
					"is to move the Chromedriver executable into a directory that is in \n" +
					"your path.\n" +

                    "\nFor your reference, here are all the directories we checked:\n\n" +
					System.getenv('PATH') +
					
					"\n\nAn alternate way is to set the path to the Chromedriver executable\n" +
					"in the gradle.properties file, at chromedriver.path\n" +
					
					"\nFor example: \n" +
					"\nchromedriver.path=C:/foo/bar/chromedriver_win32/chromedriver.exe\n" +
                    "\n\nHere is the value of your \"chromedriver.path\" \n(found in gradle.properties): \n\n" +
					chrm +

                    "\n\nIMPORTANT MESSAGES ABOVE! SCROLL UP."

            )
        }
    }

    workingDir 'src/ui_tests/behave'
    // PIPENV defaults to only two directories down respecting PIPFILE in ancestry.
    environment "PIPENV_MAX_DEPTH", "10"
    // run behave and output a json file (we'll convert that to Cucumber format later for reporting)
    commandLine 'pipenv', 'run', 'behave', '--format','json','-o','../../../build/bdd/behave.output', '-D', 'chromedriver_path='+(project.properties['chromedriver.path'] ?: "")
}

task convertBehaveOutputToCucumber(type: Exec) {
    commandLine 'pipenv', 'run', 'python', '-m', 'behave2cucumber', '-i', 'build/bdd/behave.output', '-o', 'build/bdd/behave_cucumber_style.json'
}
runBehaveTests.finalizedBy convertBehaveOutputToCucumber


task runAllTests(type: GradleBuild) {
    doFirst {
        checkIfAlive()
    }
    tasks = ['check', 'runApiTests', 'runBehaveTests']
    finalizedBy(jacocoTestReport)
}

// more info on test logging: https://discuss.gradle.org/t/whats-upcoming-in-gradle-1-1-test-logging/7741
test {
    testLogging {
        exceptionFormat "full" // default is "short"
        
        events "passed", "skipped", "failed", "standardOut", "standardError"

        showExceptions true
        showStandardStreams true
    }

    // Fail the 'test' task on the first test failure
    failFast = true

    debugOptions {
        // make the following true if you want to attach with a debugger while testing
        enabled = false
        port = 4455
        server = true
        suspend = true
    }

    // generate a report on coverage
    finalizedBy jacocoTestReport
}

dependencyCheck {
    
    scanConfigurations = ['default']
    showSummary = false
    autoUpdate = true
    cveValidForHours = 24 * 30 * 12 // about a year.
    format = 'HTML' // options are  (HTML, XML, CSV, JSON, VULN, ALL).
    failBuildOnCVSS = 8 // see https://www.first.org/cvss/specification-document#5-Qualitative-Severity-Rating-Scale
}

task('printReportPathsCheck') {
    doLast {
        print "\n\n\n"
        println "------------------------------------------------------------"
        println "Reports were generated by the tests."
        println "------------------------------------------------------------"
        println ""
        println "Coverage:   build/reports/jacoco/test/html/index.html"
        println "BDD Report: build/reports/bdd/cucumber-html-report-basic/index.html"
        println "Unit Tests: build/reports/tests/"
        println "------------------------------------------------------------"
        print "\n"
    }
}

task('coveros') {
    doLast {
      String fileContents = new File('docs/coveros_text.txt').text
      print fileContents
    }
}

check.finalizedBy 'printReportPathsCheck'

task('printReportPathsDependencyCheck') {
    doLast {
        print "\n\n\n"
        println "---------------------------------------------------------------"
        println "Reports were generated by the tests."
        println "---------------------------------------------------------------"
        println ""
        println "Dependency Check: build/reports/dependency-check-report.html"
        println "---------------------------------------------------------------"
        print "\n"
    }
}

dependencyCheckAnalyze.finalizedBy 'printReportPathsDependencyCheck'

task deployToTestWindowsLocal(type: Copy) {
    dependsOn war

    if (project.hasProperty('deploy_directory')) {
        from("$buildDir/libs/") {
            // a bit of a hack - would prefer to directly target the output of the war task
            include "*-1.0.0.war"
            rename { "demo.war" }
        }
        into "${deploy_directory}"
    }

    doLast {
        sleep 5 * 1000
    }
}

task runPerfTests(type:Exec) {
    workingDir '.'

    //on windows:
    commandLine 'jmeter.bat', '-f', '-n', '-t', 'docs\\performance_testing\\50_users_at_once.jmx', '-l', 'build\\jmeter_perf_test.csv', '-e', '-o', 'build\\reports\\perf_report'

    standardOutput = new ByteArrayOutputStream()

    ext.output = {
        return standardOutput.toString()
    }
}
wrapper {
    gradleVersion = '7.6' // or the latest supported version
}



